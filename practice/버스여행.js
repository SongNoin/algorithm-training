//* 문제 설명
// 버스정류장 N개가 있습니다. 각 정류장에는 1번부터 N번까지의 번호가 매겨져 있습니다. 2차원 배열로 주어진 정류장 표지판(signs)에는 A번 정류장에서 B번 정류장으로 가는 버스가 있다면 1, 없다면 0으로 표시되어 있습니다.

// 예를 들어, 3개의 버스정류장이 있을 때

// image

// 로 표시된 정류장 표지판이 주어진다면,

// 1번 정류장에서 2번 정류장으로 갈 수 있습니다. (A=1, B=2)
// 2번 정류장에서 3번 정류장으로 갈 수 있습니다. (A=2, B=3)
// 3번 정류장에서 1번 정류장으로 갈 수 있습니다. (A=3, B=1)
// 또한, 버스를 갈아타는 것이 가능합니다. 예를 들어, 위 예시에서는 1번에서 2번 정류장으로, 그리고 2번에서 3번 정류장으로 가는 버스가 있으므로, 한 번 갈아타서 1번에서 3번 정류장으로 갈 수 있습니다. 버스는 여러번 갈아타는 것이 가능합니다.

// 우리는 이 표를 이용해서 특정 정류장 A에서 특정 정류장 B로 갈 수 있는지 판단하여, 갈 수 있으면 1, 갈 수 없으면 0으로 표시하려고 합니다.

// 위 예시에서는

// image

// 이 되며. A번째 줄의 B번째 숫자는 A 정류장에서 B 정류장으로 갈 수 있는 지의 정보를 나타냅니다. 단, 출발지와 목적지 사이에서 적어도 하나의 버스를 타는 경우에만 1로 표시합니다.

// 정류장 표지판(signs)이 매개변수로 주어질 때, 특정 정류장 A에서 특정 정류장 B로 도달할 수 있는지를 표시하여 return 하는 solution 함수를 완성해 주세요. 위 예시의 경우는 [[1,1,1],[1,1,1],[1,1,1]]로 return 하면 됩니다.

// 제한사항
// N : 100 이하의 자연수
// 정류장 표지판(signs)는 2차원 배열이며, 1 또는 0으로만 이루어져 있습니다. 단, i번째 줄의 i번째 숫자는 항상 0입니다.
// 입출력 예
// n	signs	answer
// 3	[[0,1,0],[0,0,1],[1,0,0]]	[[1,1,1],[1,1,1],[1,1,1]]
// 3	[[0,0,1],[0,0,1],[0,1,0]]	[[0,1,1],[0,1,1],[0,1,1]]
// 입출력 예 설명
// 입출력 예 #1
// 문제의 예시와 같습니다.

// 입출력 예 #2

// 1번 정류장->3번 정류장->2번 정류장으로 갈 수 있으므로, 1행은 [0,1,1]이 됩니다.
// 2번 정류장->3번 정류장->2번 정류장으로 갈 수 있으므로, 2행은 [0,1,1]이 됩니다.
// 3번 정류장->2번 정류장->3번 정류장으로 갈 수 있으므로, 3행은 [0,1,1]이 됩니다

//* 중요포인트
// 1. 문제가 많이 어려워서 긴 고민에 빠졌을때 입출력 예 #2 를 읽고 생각보다 간단하게 풀 수 있음을 알았다. 문제 그대로 코드를 구현해보니 3중 for문이 되었다.
// 2. 통과가 반절만 되었을 때의 실수는 3중 for문이다보니 변수 위치에 대해 너무 어려웠다. 그래서 이상하게 했었다 i의 위치가 중요했다.

//* 내 풀이

function solution(n, signs) {
  for (let i = 0; i < n; i++) {
    for (let j = 0; j < n; j++) {
      for (let k = 0; k < n; k++)
        if (signs[j][i] === 1 && signs[i][k] === 1) signs[j][k] = 1;
    }
  }
  return signs;
}
